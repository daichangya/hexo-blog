---
title: NC(netcat)使用指南
id: 1039
date: 2024-10-31 22:01:48
author: daichangya
excerpt: 第一次知道nc（netcat）是好几年前的事了，那个时候天比现在更蓝，草比现在更绿，卤煮也还是一个刚上大学不久的青葱骚年...现在把这个01年的老古董拿出来说好像有点炒冷饭的意思，资料也铺天盖地了说多了还惹人嫌。        不过没办法啊，毕竟当卤煮逐渐发现它有许多颇有内涵的功能的时候，连小伙伴都让它给惊呆了
  D ...
permalink: /archives/NC-netcat-shi-yong-zhi-nan/
tags:
- linux
---


        第一次知道nc（netcat）是好几年前的事了，那个时候天比现在更蓝，草比现在更绿，卤煮也还是一个刚上大学不久的青葱骚年...

现在把这个01年的老古董拿出来说好像有点炒冷饭的意思，资料也铺天盖地了说多了还惹人嫌。

        不过没办法啊，毕竟当卤煮逐渐发现它有许多颇有内涵的功能的时候，连小伙伴都让它给惊呆了 :D ...

  

        由于对hacker文化的兴趣，顺理成章的在合适的时候发现了nc，但当时的卤煮正值被铺天盖地的计算机的方方面面知识砸的晕晕乎乎的人生阶段...对于这个一直享有瑞士军刀之名的软件，找过来看了两把完全没有发现其中的滚滚内涵~

  

        因为是这样的，nc提供的基本功能并不多，windows版本的 "prompt> nc -h" 所给出的所谓官方操作文档不过下面这寥寥数语：

```perl
[v1.11 NT www.vulnwatch.org/netcat/]
connect to somewhere:   nc [-options] hostname port[s] [p
listen for inbound:     nc -l -p port [options] [hostname
options:
        -d              detach from console, background m

        -e prog         inbound program to exec [dangerou
        -g gateway      source-routing hop point[s], up t
        -G num          source-routing pointer: 4, 8, 12,
        -h              this cruft
        -i secs         delay interval for lines sent, po
        -l              listen mode, for inbound connects
        -L              listen harder, re-listen on socke
        -n              numeric-only IP addresses, no DNS
        -o file         hex dump of traffic
        -p port         local port number
        -r              randomize local and remote ports
        -s addr         local source address
        -t              answer TELNET negotiation
        -u              UDP mode
        -v              verbose [use twice to be more ver
        -w secs         timeout for connects and final ne
        -z              zero-I/O mode [used for scanning]
port numbers can be individual or ranges: m-n [inclusive]
```

  

-d  字面上大约是后台运行的意思，不占用当前shell

-e  这个参数大有内涵...网上一般翻译成程序重定向什么的，但是重定向这个词... 卤煮暂时没去看源码，不知道其具体做了什么事情，但猜测可能是fork一个子进程exec用户程序，然后父进程wait子进程的做法。这个-e用在server端的时候，目测是在accept成功之后，然后把这个用户程序的输入输出重定向到clientsocket对应的readfd和writefd上。具体应用下面再说。

-g  额...这个参数从文档字面上看不太懂（一堆英文专业术语冒出来好可怕... :X)。有些同学翻译成“源路由跳点”实在是太翻译软件了...看下资料大致上是为了做到强制数据流经这些节点，这样就有机会做到类似利用节点IP巧妙的避开目标机的ACL限制这样的功能。官文用了一个词叫“loose-source-routed path”，loose猜测意思大约是指仅简单的保证会经过-g给的节点，并不能保证以这条列表的所示路径来完成链路的意思，因为路由发包所选择的下一个hop是有自己的路由策略的吧，所以保证不了两个路由间的具体路径。。各个操作系统的版本不一定都支持-g，至于数据是否会依照所给节点顺序来传递现在也还不是很清楚。

-G  在-g所给列表中选择一个地址作为当前的下一个路由，据说是因为IP的内存对象都是4字节存储，所以-G所给参数也得是4的倍数，虽然自己换算下也没什么但这种设计只能用惨无人道来形容。这个功能据说在“网络诈骗”方面有一定用武之地，这个卤煮暂时没感受。（centos装了个版本没有-g 和 -G）

-h  for help

-i  每行数据发送出去的延时时间吧（秒）

-l  会listen的东东我们都管他叫server...理解成server mode就好，一次性行为（怎么读都可以...）

-L  和-l做的事情一样，区别在这个“re”上，客户端端口后依然保持

-n  表示connect的目标地址是一个ip，可以略过dns的过程，这个参数一般情况下加不加好像无所谓吧，不加n也可以直接用ip的。

-o  把往来数据log起来，监控用

-p  后面跟端口号，指定一个端口

-r  在范围扫描端口的时候，即执行类似 nc -v 127.0.0.1 1-1000 这样的操作时，加上r参数可以使每次扫描的端口号随机化，否则一般是从高到低依序扫描。

-s  翻译过来叫nc建立连接时用的IP地址，据说可以仿冒本地地址，暂时还不太知道怎么使用。

-t  以telnet方式进行交互，这个暂时不知道和普通的字符方式有何区别...

-u  UDP mode，比如扫端口的时候，带u扫UDP端口，不带就默认扫TCP端口

-v  提示信息，连着两个v会得到更加详细的提示信息，具体区别实际用的时候自己去感受下

-w  connect时的超时时间，一般扫描端口的时候会加上

-z  关闭IO，就是英文字面上的意思，用途也说了。

  

  

        无意在文档泛滥成灾的网络上再加一般劣质文档，总之就是先总结下感受这样子，有助卤煮记忆。

        如这些参数所见，除了暂时看上去显得很高端大气上档次的-g -G组合之外，nc实际上只作了很少的事情。无非是每个学过网络编程的人都反反复复写过的小例子像什么connect、listen、bind、read、write、execxx、sleep、IO重定向之类的组合一下。对于思路不够开阔的人（比如卤煮）来说，好像这样的软件根本做不了什么事情。说起来反而是自己以前把网络中用到的许多功能自己给想太复杂了，总觉得要做到某个具体的功能是需要为此写份代码，于是这事那事的一拖再拖最后啥事儿也没去干。

  

        前几天要重新学习下编写server，刚准备动手写个client以便测试的时候突然灵感一闪，想起了阔别已久的nc，然后便一发不可收拾的用了下去。发现它能做到的事情实在是很多，真是印证了那句话，“简单即是美好”。

  

**扫描端口：**

        nc -nvvz -w2 127.0.0.1 1-1000

        最基本的功能之一了，扫描目标ip的端口段，然后用-w加上一个超时时间。参数里加上r使得端口扫描变得随机一些，对方log里看起来不那么像是被扫描的（其实还是很容易看出来）。

  

**连接到目标：**

        nc -nvv 127.0.0.1 8089

        作为测试客户端非常常用的功能，即连接到目标ip的某个端口上。连接上之后会把stdin的数据发给server。 

        在确定服务端正常开启的情况下连接被拒多半要去检查下防火墙设置。

  

**服务器：**

        nc -lvv -p 8089

        让nc作为一个server监听8089端口，把stdin的数据发给client。

  

**传文件：**

        其实和nc没啥关系，主要利用了系统IO重定向或pipe的功能，标准化带来的好处多多。

        发送端通过pipe把文件数据传递给stdin，或者通过重定向把stdin重定向到某个文件上，然后接受端只要对stdout进行重定向把它定向到目标文件上去即可。

        比如：

        server: nc -lvv -p 8089 < my.txt

        client: nc -nvv serverip 8089 > my.txt

        当你在纠结两台机子传个文件到底是用网络共享好还是利用中间ftp好又或者是scp甚至于给自己发个邮件另一台机子上去下载的时候，这简直是你的诺亚方舟。

        这个功能说成传文件说的有些狭隘了，总之就是传递数据，理论上可以把接收端的数据（可能是某种格式编码的）直接传给对应的处理软件去执行，举个例子比如说看个视频什么的。

  

**得到对端机子的shell：**

        -e的邪恶能力终于派上用场了。

        一台机子上 nc -lvv -p 8089 -t -e cmd.exe

        然后你去连它的时候神奇的事情发生了，自己的终端会变成对方机子的终端，可以随便做邪恶的事情（在用户权限范围下），原理的话估计和我上面写的类似。

        如果对方机子的nc支持-d，那就更理想一点，加上这个参数使得nc后台运行更加难以发现，更进一步的，修改nc.exe的文件名使查看进程的时候别人也不容易起疑。这个NB的功能除了拿来动真刀真枪之外，还能怎么玩其实主要看-e后面的这个用户程序怎么去写吧，这个还是自己去找灵感。

  

**蜜罐：**

        还是作为server的基本功能来说，思路不一样会发现用途立刻就大相径庭了。比如说你没事儿listen一个端口，然后-o 来打log，闲来喝喝茶翻翻log，你就能知道都有哪些人对你的这个端口感兴趣（嘿嘿嘿...）

        更进一步的，因为许多小坏蛋们总是用一些安全渗透工具来找空子，毕竟是工具嘛，识别一些漏洞总是有一组傻乎乎的规则的，如果想要捉弄他们让他们误以为真的有漏洞而采取进一步措施的话，可以结合nc的数据传输功能和-e再加上自写程序来伪造一个。不过小心玩火自焚喽。

  

**反向链接：**

        前面说一个拿到server shell的情况，要求server端绑定一个shell程序到端口上。那么实际应用情境中，一般就是小坏蛋给小绵羊电脑上种一个server啦，然后每次小坏蛋去连接都能得到shell。但由于种种问题，小坏蛋要直接连到小绵羊电脑可能比较麻烦，尤其是小绵羊电脑在一个局域网中，通过nat上网的情况下。

        为了解决这个问题，可以换一种思路，小绵羊作为主动发起端并自己绑定一个shell程序到nc，要实现这个步骤可能是小坏蛋哪天千辛万苦入了小绵羊电脑设了一个计划任务，也可能是小坏蛋到小绵羊家里玩的时候在小绵羊电脑里使了个坏...然后小坏蛋电脑只需要安心开着server等小绵羊上钩，每次小绵羊连接到server就自动把自己卖了出去...

        原理的话，猜测是在阻塞connect成功之后fork然后exec，再wait，和主动连接差不多的。不过反向链接省去了正面突围的大麻烦，功德一件，善哉善哉。

  

  

        看到比较典型的大概有上面这几种，熟悉的人肯定已经熟悉的不能再熟了。通过和各个系统工具的组合想必还有更多好玩的用法的，所以nc可是一个很益智的玩具呢，当然它不仅仅是玩具，必要时也可能帮你解决实际问题。

        综合来看，nc在许多方面的功能都有比较好用的独立软件，这也侧面反应了nc在这些功能上都有许多做的不够好的地方（没有足够多针对性的优化和扩展功能）。但它胜在麻雀虽小但五脏俱全，这一点十分讨人喜欢，在许多没有特点工作环境的场合会是非常有吸引力的选择。

        虽然还没有深度使用这个工具，不过有预感结合自编脚本来用的话，应该会表现的更加出彩一些。

  

        就像语言影响人的思维面一样，工具的掌握让人更加清晰的认识到何事可为何事不可为，从而进一步影响决策和行为。

  

        为了进化而努力。