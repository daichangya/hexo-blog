---
title: 一个规则引擎的可视化方案 
id: 1628
date: 2024-10-31 22:02:04
author: daichangya
permalink: /archives/%E4%B8%80%E4%B8%AA%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88/
tags: 
 - 规则引擎
---


# 背景

最近有个新项目可能会用到规则引擎，所以花了些时间对相关技术做调研，在百度、google用“规则引擎”作为关键字进行搜索，可以找到很多关于这方面的资料，绝大部分都会提到 drools、urules、easy-rules等等这么些开源项目，有一些文章也提到他们是采用groovy脚本来实现的。通过对项目需求的评估，初步判定groovy脚本已经可以满足实际的场景。

然而，在这些资料或者方案之中，除了urules，大部分只是关注框架的性能和使用上的简便，很少探讨如何让业务人员可以自行进行规则定义的方案。而urules虽然自带了可视化的规则管理界面，但是界面样式不好自定义，无法跟现有后台管理界面不突兀的融合。

通过不断尝试变换关键字在搜索引擎搜索，最终在stackoverflow找到了一个探讨这个问题的帖子，特此将帖子中提到的方案分享一下，如果你跟我一样在研究同样的问题，也许对你有用。不过在介绍这个方案之前，得先简单了解一下什么是规则引擎

# 什么是规则引擎？

简单的说，规则引擎所负责的事情就是：判定某个数据或者对象是否满足某个条件，然后根据判定结果，执行不同的动作。例如：

```bash
对于刚刚在网站上完成购物的一个用户（对象），如果她是 "女性用户 并且 （连续登录天数大于10天 或者 订单金额大于200元 )" (条件) , 那么系统就自动给该用户发放一张优惠券（动作）。

```

在上面的场景中，规则引擎最重要的一个优势就是实现“条件“表达式的配置化。如果条件表达式不能配置，那么就需要程序员在代码里面写死各种if...else... ，如果条件组合特别复杂的话，代码就会很难维护；同时，如果不能配置化，那么每次条件的细微变更，就需要修改代码，然后通过运维走发布流程，无法快速响应业务的需求。

在groovy脚本的方案中，上面的场景可以这么实现：

*   1）定义一个groovy脚本：

```groovy
def validateCondition(args){return args.用户性别 == "女性" && (args.连续登录天数>10 || args.订单金额 > 200);}

```

*   2）通过Java提供的 ScriptEngineManager 对象去执行

```xml
    <dependency>
      <groupId>org.codehaus.groovy</groupId>
      <artifactId>groovy</artifactId>
      <version>3.0.7</version>
    </dependency>

```

```java
/*
 *
 * @params condition  从数据库中读出来的条件表达式
 */
private Boolean validateCondition(String condition){
    //实际使用上，ScriptEngineManager可以定义为单例
    ScriptEngineManager engineManager = new ScriptEngineManager();
    ScriptEngine engine = engineManager.getEngineByName(scriptLang);
    Map<String, Object> args = new HashMap<>();
    data.put("用户性别", "女性");
    data.put("连续登录天数", 11);
    data.put("订单金额", 220);
    engine.eval(script);
    return ((Invocable) engine).invokeFunction("validateCondition", args);
}

```

在上面的groovy脚本中，经常需要变动的部分就是 ”args.用户性别 == "女性" && (args.连续登录天数>10 || args.订单金额 > 200)“ 这个表达式，一个最简单的方案，就是在后台界面提供一个文本框，在文本框中录入整个groovy脚本，然后保存到数据库。但是这种方案有个缺点：表达式的定义有一定门槛。对于程序员来说，这自然是很简单的事，但是对于没接触过编程的业务人员，就有一定的门槛了，很容易录入错误的表达式。这就引出了本文的另一个话题，如何实现bool表达式的可视化编辑？

# 如何实现bool表达式的可视化编辑？

一种方案就是对于一个指定的表达式，前端人员进行语法解析，然后渲染成界面，业务人员编辑之后，再将界面元素结构转换成表达式。然而，直接解析语法有两缺点：

*   1）需要考虑的边界条件比较多，一不小心就解析出错。
*   2）而且也限定了后端可以选用的脚本语言。例如，在上面的方案中选用的是groovy，它使用的"与"运算符是 && , 假如某天有一种性能更好的脚本语言，它的"与"运算符定位为 and ，那么就会需要修改很多表达式解析的地方。

另一种方案，是定义一个数据结构来描述表达式的结构(说了这么多，终于来到重点了)：

```javascript
    { "all": [
        { "any": [
            { "gt": ["连续登录天数", 10] },
            { "gt": ["订单金额", 200] }
        ]},
        { "eq": ["用户性别", "女性"] }
    ]}

```

然后，使用递归的方式解析该结构，对于前端开发，可以在递归解析的过程中渲染成对应的界面元素；对于后端人员，可以生成对应的bool表达式，有了bool表达式，就可以使用预定的脚本模板，生成最终的规则。

```javascript
// 模板的例子
def validateCondition(args){return $s;}

```

```java
/**
 * 动态bool表达式解析器
 */
public class RuleParser {
    private static final Map<String, String> operatorMap = new HashMap<>();
    private static final ObjectMapper objectMapper = new ObjectMapper();

    static {
        operatorMap.put("all", "&&");
        operatorMap.put("any", "||");
        operatorMap.put("ge", ">=");
        operatorMap.put("gt", ">");
        operatorMap.put("eq", "==");
        operatorMap.put("ne", "!=");
        operatorMap.put("le", "<=");
        operatorMap.put("lt", "<");
    }

    /**
     * 解析规则字符串，转换成表达式形式
     * 示例:
     * 输入：
     *    { "any": [
     *        { "all": [
     *            { "ge": ["A", 10] },
     *            { "eq": ["B", 20] }
     *        ]},
     *        { "lt": ["C", 30] },
     *        { "ne": ["D", 50] }
     *    ]}
     *
     * 输出：
     *    ( A >= 10 && B == 20 ) || ( C < 30 ) || ( D != 50 )
     * @param rule 规则的json字符串形式
     * @return 返回 bool 表达式
     * @throws IOException 解析json字符串异常
     */
    public static String parse(String rule) throws IOException {

        JsonNode jsonNode = objectMapper.readTree(rule);
        return parse(jsonNode);
    }

    /**
     * 解析规则节点，转换成表达式形式
     * @param node Jackson Node
     * @return 返回bool表达式
     */
    private static String parse(JsonNode node) {
        // TODO: 支持变量的 ”arg.“ 前缀定义
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> it = node.fields();
            if(it.hasNext()){
                Map.Entry<String, JsonNode> entry = it.next();
                List<String> arrayList = new ArrayList<>();
                for (JsonNode jsonNode : entry.getValue()) {
                    arrayList.add(parse(jsonNode));
                }

                return "(" + String.join(" " + operatorMap.get(entry.getKey()) + " ", arrayList) + ")";
            } else {
                // 兼容空节点：例如 {"all": [{}, "eq":{"A","1"}]}
                return " 1==1";
            }
        } else if (node.isValueNode()) {
            return node.asText();
        }

        return "";
    }

```

# 结语

以上就是本文要阐述的全部内容，对于这个话题，如果你有这方面的经验或者更好的方案，也请多多指教，谢谢！

完整源码：[https://github.com/RongieZeng/rule-parser](https://github.com/RongieZeng/rule-parser)
